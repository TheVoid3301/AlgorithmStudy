# 树的构建

## 前序遍历（preorder）、中序遍历（inorder):

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

// 二叉树节点的定义
struct TreeNode {
    int val;            // 节点的值
    TreeNode *left;     // 左子节点指针
    TreeNode *right;    // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 构造函数
};

/**
 * 递归辅助函数：根据前序和中序遍历的指定区间，构建二叉树
 *
 * @param preorder      前序遍历数组（全局不变）
 * @param preStart      当前子树在前序数组中的起始索引
 * @param preEnd        当前子树在前序数组中的结束索引
 * @param inorder       中序遍历数组（全局不变）
 * @param inStart       当前子树在中序数组中的起始索引
 * @param inEnd         当前子树在中序数组中的结束索引
 * @param inorderIndexMap  哈希表：存储中序遍历中每个值对应的索引（用于快速查找根的位置）
 * @return              返回当前子树的根节点指针
 */
TreeNode* buildTreeHelper(
    const vector<int>& preorder, size_t preStart, size_t preEnd,
    const vector<int>& inorder, size_t inStart, size_t inEnd,
    unordered_map<int, size_t>& inorderIndexMap
) {
    // 递归终止条件：如果索引越界，说明当前子树为空
    if (preStart > preEnd || inStart > inEnd) {
        return nullptr;
    }

    // 前序遍历的第一个元素就是当前子树的根节点
    int rootValue = preorder[preStart];
    TreeNode* root = new TreeNode(rootValue);

    // 在中序遍历中找到根节点的位置
    size_t inorderRootIndex = inorderIndexMap[rootValue];

    // 计算左子树包含的节点数量
    size_t leftSubtreeSize = inorderRootIndex - inStart;

    // 递归构建左子树：
    // - 前序区间：从 preStart+1 开始，共 leftSubtreeSize 个元素
    // - 中序区间：从 inStart 到 inorderRootIndex-1
    root->left = buildTreeHelper(
        preorder, preStart + 1, preStart + leftSubtreeSize,
        inorder, inStart, inorderRootIndex - 1,
        inorderIndexMap
    );

    // 递归构建右子树：
    // - 前序区间：从 preStart + leftSubtreeSize + 1 到 preEnd
    // - 中序区间：从 inorderRootIndex + 1 到 inEnd
    root->right = buildTreeHelper(
        preorder, preStart + leftSubtreeSize + 1, preEnd,
        inorder, inorderRootIndex + 1, inEnd,
        inorderIndexMap
    );

    return root;
}

/**
 * 主函数：根据前序遍历和中序遍历构建二叉树
 *
 * @param preorder  前序遍历序列
 * @param inorder   中序遍历序列
 * @return          重建的二叉树的根节点
 */
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    // 创建哈希表，将中序遍历中每个值映射到其索引位置
    // 这样可以在 O(1) 时间内找到根节点在中序中的位置
    unordered_map<int, size_t> inorderIndexMap;
    for (size_t i = 0; i < inorder.size(); ++i) {
        inorderIndexMap[inorder[i]] = i;
    }

    // 调用递归辅助函数，初始范围是整个数组
    return buildTreeHelper(
        preorder, 0, preorder.size() - 1,
        inorder, 0, inorder.size() - 1,
        inorderIndexMap
    );
}

/**
 * 辅助函数：中序遍历输出二叉树（用于验证结果是否正确）
 */
void printInOrder(TreeNode* node) {
    if (node == nullptr) return;

    printInOrder(node->left);   // 先遍历左子树
    cout << node->val << " ";   // 再访问根节点
    printInOrder(node->right);  // 最后遍历右子树
}

// 主函数：测试示例
int main() {
    // 示例输入
    vector<int> preorder = {3, 9, 20, 15, 7};  // 前序遍历
    vector<int> inorder  = {9, 3, 15, 20, 7};  // 中序遍历

    // 构建二叉树
    TreeNode* root = buildTree(preorder, inorder);

    // 输出中序遍历结果，验证是否与原 inorder 一致
    cout << "重建后的中序遍历: ";
    printInOrder(root);
    cout << endl; // 应输出: 9 3 15 20 7

    return 0;
}
```

后序遍历（postorder）、中序遍历（inorder):

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

// 二叉树节点的定义
struct TreeNode {
    int val;            // 节点的值
    TreeNode *left;     // 左子节点指针
    TreeNode *right;    // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 构造函数
};

/**
 * 递归辅助函数：根据中序和后序遍历的指定区间，构建二叉树
 *
 * @param inorder       中序遍历数组（全局不变）
 * @param inStart       当前子树在中序数组中的起始索引
 * @param inEnd         当前子树在中序数组中的结束索引
 * @param postorder     后序遍历数组（全局不变）
 * @param postStart     当前子树在后序数组中的起始索引
 * @param postEnd       当前子树在后序数组中的结束索引
 * @param inorderIndexMap  哈希表：存储中序遍历中每个值对应的索引（用于快速查找根的位置）
 * @return              返回当前子树的根节点指针
 */
TreeNode* buildTreeHelper(
    const vector<int>& inorder, size_t inStart, size_t inEnd,
    const vector<int>& postorder, size_t postStart, size_t postEnd,
    unordered_map<int, size_t>& inorderIndexMap
) {
    // 递归终止条件：如果索引越界，说明当前子树为空
    if (inStart > inEnd || postStart > postEnd) {
        return nullptr;
    }

    // 后序遍历的最后一个元素就是当前子树的根节点
    int rootValue = postorder[postEnd];
    TreeNode* root = new TreeNode(rootValue);

    // 在中序遍历中找到根节点的位置
    size_t inorderRootIndex = inorderIndexMap[rootValue];

    // 计算左子树包含的节点数量
    size_t leftSubtreeSize = inorderRootIndex - inStart;

    // 递归构建左子树：
    // - 中序区间：从 inStart 到 inorderRootIndex-1
    // - 后序区间：从 postStart 到 postStart + leftSubtreeSize - 1
    root->left = buildTreeHelper(
        inorder, inStart, inorderRootIndex - 1,
        postorder, postStart, postStart + leftSubtreeSize - 1,
        inorderIndexMap
    );

    // 递归构建右子树：
    // - 中序区间：从 inorderRootIndex + 1 到 inEnd
    // - 后序区间：从 postStart + leftSubtreeSize 到 postEnd - 1
    root->right = buildTreeHelper(
        inorder, inorderRootIndex + 1, inEnd,
        postorder, postStart + leftSubtreeSize, postEnd - 1,
        inorderIndexMap
    );

    return root;
}

/**
 * 主函数：根据中序遍历和后序遍历构建二叉树
 *
 * @param inorder   中序遍历序列
 * @param postorder 后序遍历序列
 * @return          重建的二叉树的根节点
 */
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    // 创建哈希表，将中序遍历中每个值映射到其索引位置
    // 这样可以在 O(1) 时间内找到根节点在中序中的位置
    unordered_map<int, size_t> inorderIndexMap;
    for (size_t i = 0; i < inorder.size(); ++i) {
        inorderIndexMap[inorder[i]] = i;
    }

    // 调用递归辅助函数，初始范围是整个数组
    return buildTreeHelper(
        inorder, 0, inorder.size() - 1,
        postorder, 0, postorder.size() - 1,
        inorderIndexMap
    );
}

/**
 * 辅助函数：中序遍历输出二叉树（用于验证结果是否正确）
 */
void printInOrder(TreeNode* node) {
    if (node == nullptr) return;

    printInOrder(node->left);   // 先遍历左子树
    cout << node->val << " ";   // 再访问根节点
    printInOrder(node->right);  // 最后遍历右子树
}

// 主函数：测试示例
int main() {
    // 示例输入
    vector<int> inorder  = {9, 3, 15, 20, 7};  // 中序遍历
    vector<int> postorder = {9, 15, 7, 20, 3}; // 后序遍历

    // 构建二叉树
    TreeNode* root = buildTree(inorder, postorder);

    // 输出中序遍历结果，验证是否与原 inorder 一致
    cout << "重建后的中序遍历: ";
    printInOrder(root);
    cout << endl; // 应输出: 9 3 15 20 7

    return 0;
}
```

