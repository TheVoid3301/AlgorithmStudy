例题:

​	**L2-006 树的遍历**

​		题目要求为根据后序遍历和前序遍历构建二叉树, 然后输出层序遍历

```c++
#include "cstdio"
#include "algorithm"
#include "cstring"
using namespace std;
const int maxn = 10000+10;

//  层序遍历    后序遍历     中序遍历
int res[maxn], pos[maxn], in[maxn];

//构建二叉树
/**
	L:当前二叉树的中序遍历的左边界
	R:当前二叉树的中序遍历的右边界
	idx:层序遍历编号
	root:遍历的当前二叉树的根节点编号
*/
void build(int L, int R, int idx, int root) {
    //如果边界范围不存在
    if (L > R) return;
    //第idx号层序遍历为当前遍历树的根节点
    res[idx] = pos[root];
    int i = L;
    //找到当前根节点再中序遍历中的位置
    while (in[i] != pos[root]) i++;
    //遍历左树
    build(L, i-1, idx*2+1, root-1-R+i);
    //遍历又树
    build(i+1, R, idx*2+2, root-1);
}


int main(int argc, char const *argv[])
{
    int N;
    scanf("%d", &N);
    for (int i = 0; i < 10000; i++) res[i] = -1;
    for (int i = 0; i < N; i++) scanf("%d", pos+i);
    for (int i = 0; i < N; i++) scanf("%d", in+i);
    build(0, N-1, 0, N-1);
    printf("%d", res[0]);
    int cnt = 1;
    int i = 1;
    while (cnt < N) {
        if (res[i] != -1) {
            printf(" %d", res[i]);
            cnt++;
        }
        i++;
    }
    printf("\n");
    return 0;
}
```