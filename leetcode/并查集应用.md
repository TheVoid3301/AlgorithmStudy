# 并查集应用

## **L2-007 家庭房产**

给定每个人的家庭成员和其自己名下的房产，请你统计出每个家庭的人口数、人均房产面积及房产套数。

### 输入格式：

输入第一行给出一个正整数*N*（≤1000），随后*N*行，每行按下列格式给出一个人的房产：

编号 父 母 k 孩子1 ... 孩子k 房产套数 总面积

其中`编号`是每个人独有的一个4位数的编号；`父`和`母`分别是该编号对应的这个人的父母的编号（如果已经过世，则显示`-1`）；`k`（0≤`k`≤5）是该人的子女的个数；`孩子i`是其子女的编号。

### 输出格式：

首先在第一行输出家庭个数（所有有亲属关系的人都属于同一个家庭）。随后按下列格式输出每个家庭的信息：

家庭成员的最小编号 家庭人口数 人均房产套数 人均房产面积

其中人均值要求保留小数点后3位。家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。

```c++
#include <bits/stdc++.h>
using namespace std;
int fa[10050]; //记录祖先
set<int> peo;  //记录所有人的编号，在输入的时候记录就行了，有的编号输入时出现不止一次所以用set确保唯一
struct people  //房产信息，完全可以用map来代替head数组
{
    int rooms;
    double S;
} head[10050];
struct answer //结果，一个家族的全部信息，用最小编号映射家族信息
{
    int minid;
    int num;
    int rooms;
    double S;
}; //家庭个数
map<int, answer> mp;
void init() //fa数组初始化
{
    for (int i = 0; i < 10050; i++)
        fa[i] = i;
}

int Find(int a) //找祖先
{
    if (fa[a] == a)
        return a;
    else
        return fa[a] = Find(fa[a]);
}

void Union(int a, int b) //合并祖先
{
    int f1 = Find(a);
    int f2 = Find(b);
    if (f1 < f2)     //最小的为祖先
        fa[f2] = f1; //修改的是祖先的祖先，祖先的祖先就是其本身
    else
        fa[f1] = f2;
}
//排序比较函数
bool cmp(answer &a1, answer &a2)
{
    if (a1.S / a1.num == a2.S / a2.num)
        return a1.minid < a2.minid;
    return a1.S / a1.num > a2.S / a2.num;
}

void test()
{
    init();
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int id, p1, p2, knum, k;//分别代表 本人 父 母 孩子数量 孩子
        cin >> id >> p1 >> p2 >> knum;
        peo.insert(id);//记录所有编号
        if (p1 != -1)
        {
            peo.insert(p1);//记录所有编号
            Union(id, p1);
        }
        if (p2 != -1)
        {
            peo.insert(p2);//记录所有编号
            Union(id, p2);
        }
        for (int j = 0; j < knum; j++)
        {
            cin >> k;
            peo.insert(k);//记录所有编号
            Union(id, k);
        }
        cin >> head[id].rooms >> head[id].S;
    }

    for (int i : peo)//遍历set，只需要得到编号即可，mp中保存的是最后结果
    {
        int id = Find(i);
        mp[id].minid = id;
        mp[id].num++;
        mp[id].S += head[i].S;
        mp[id].rooms += head[i].rooms;
    }
    cout << mp.size() << endl;
    vector<answer> res;//转到数组中对其进行排序输出
    for (auto i : mp)
    {
        res.push_back(i.second);
    }
    //排序
    sort(res.begin(), res.end(), cmp);
    //输出结果
    for (auto i : res)
        printf("%04d %d %.3lf %.3lf\n", i.minid, i.num, 1.0 * i.rooms / i.num, 1.0 * i.S / i.num);
}

int main()
{
    test();
    return 0;
}
```

